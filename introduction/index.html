<!-- 
Interview Cheat Sheet



#Big O Cheat Sheet:
-Big Os

O(1) Constant- no loops

O(log N) Logarithmic- usually searching algorithms have log n if they are sorted (Binary Search)

O(n) Linear- for loops, while loops through n items

O(n log(n)) Log Liniear- usually sorting operations

O(n^2) Quadratic- every element in a collection needs to be compared to ever other element. Two
nested loops

O(2^n) Exponential- recursive algorithms that solves a problem of size N

O(n!) Factorial- you are adding a loop for every element

Iterating through half a collection is still O(n)
Two separate collections: O(a * b)

-What can cause time in a function?-
Operations (+, -, *, /)
Comparisons (<, >, ==)
Looping (for, while)
Outside Function call (function())

-Rule Book

Rule 1: Always worst Case
Rule 2: Remove Constants
Rule 3: Different inputs should have different variables. O(a+b). A and B arrays nested would be
O(a*b)
+ for steps in order
* for nested steps
Rule 4: Drop Non-dominant term


-What causes Space complexity?

Variables
Data Structures
Function Call
Allocation



How to tackle DSA style interviews


- Step by Step approach through a problem

1. When the interviewer asks the question, try to write it out plainly in your own words to aid understanding the contexts and naunces
2. Double check by asking questions e.g what are the inputs or outputs? array, string?
3. What is the most important value of the question
4. Don't ask annoying questions
5. Start with a naive solution - don't overthink the perfect solution just yet
6. Walkthrough your thinking process out loud - this gives the interviewer the opportunity to know your thought process
7. Upon arriving at a working naive solution, tell them about the improvements that can be made to the first solution
8. Start coding and ensure to talk about each as you do
9. Think about error checks
10. Use proper variable names & modularity - break up code into smaller chunks and comment them properly
11. Test your code
12. Talk about further improvements



- Good code checks

[] It works
[] Good use of data structures
[] Code re-use / DRY
[] Modularity
[] Less O(N^2)
[] Less space complexity


- Heurestics to ace questions

[] Hash Maps are usually the answer to solve for Time Complexities
[] if it's a sorted array, use Binary tree to achieve O(log(n))
[] Look at the Time vs Space tradeoffs


And always remember: Communicate your thought process as much as possible. Donâ€™t worry about
finishing it fast. Every part of the interview matters.
-->


<!-- 

1. Google Mock Interview

* Rough 
const x = [1,2,3,4,6,2]
const y = [1,2,4,4,8,0]
const sum = 8

const hasPairSum = (arr, sum) => {

let low = 0
let high = arr.length - 1

while(low < high){
  low++
  const s = arr[low] + arr[high]
  if(s==sum){
  return true
  }
  false
}

}

hasPairSum(x,8)


* Naive (o(n^2))
const hasPairSum = (arr, sum) => {
let len = arr.length
  for(i=0; i<len-1, i++){
     for(j=i+1, j<len, j++){
      if(arr[i] + arr[j] === sum){
       return true
      }
     } 
  }
      return false
}

* Better
const hasPairSum = (arr, sum) => {
 const set = new Set()
 for(i=0; i<arr.length, i++){
  if(set.has(arr[i])){
     return true
  }
     set.add(sum-arr[i])
 }
    return false
}


2. ZTM Starter Algo

// Given 2 arrays, create a function that let's a user know (true/false) whether these two arrays contain any common items
//For Example:
//const array1 = ['a', 'b', 'c', 'x'];
//const array2 = ['z', 'y', 'i'];
//should return false.
//-----------
//const array1 = ['a', 'b', 'c', 'x'];
//const array2 = ['z', 'y', 'x'];
//should return true.

// 2 parameters - arrays - no size limit
// return true or false


* Naive (O(n^2))
const hasSameElement = (arr1, arr2) => {

  for(i=0; i<arr1.length, i++){
     for(j=0, j<arr2.length; j++){
      if(arr[i] === arr[j]){
       return true
      }
     } 
  }
      return false
}


* Semi Native (O(a + b))

const hasSameElement = (arr1, arr2) => {


// create an object with arr1 element as key
let map = {}
for(i=0; i<arr1.length; i++){
   if(!map[arr1[i]]){
     map[arr1[i]] = true
   }  
}

// loop through second array and check if same element exists in obj created above
for(j=0; j<arr2.length; j++){
 if(map[arr2[j]]){
   return true
}
}

return false

}



* Short Hand 

const hasSameElement = (arr1, arr2) => {
  return arr1.some(item => arr2.includes(item))
}



-->